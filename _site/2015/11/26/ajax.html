<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Sakuya's Blog"><meta name="keywords" content="Sakuya,人間開花,咲夜,咲夜君"><title>XMLHttpRequest - 人間開花</title><link rel="stylesheet" href="/css/main.css"><link rel="shortcut icon" href="/favicon.ico"><title>XMLHttpRequest | 人間開花</title><meta name="generator" content="Jekyll v3.8.1" /><meta property="og:title" content="XMLHttpRequest" /><meta property="og:locale" content="en_US" /><meta name="description" content="Ajax（Asynchronous JavaScript + XML）技术能够向服务器请求额外数据并对页面进行一些填充处理但刷新页面，这会带来更好的用户体验。它依赖现有的CSS/HTML/JavaScript，其中技术核心是XMLHttpRequest对象（简称XHR），是这个对象使得浏览器可发出HTTP请求与接受HTTP请求。" /><meta property="og:description" content="Ajax（Asynchronous JavaScript + XML）技术能够向服务器请求额外数据并对页面进行一些填充处理但刷新页面，这会带来更好的用户体验。它依赖现有的CSS/HTML/JavaScript，其中技术核心是XMLHttpRequest对象（简称XHR），是这个对象使得浏览器可发出HTTP请求与接受HTTP请求。" /><link rel="canonical" href="http://localhost:4000/2015/11/26/ajax.html" /><meta property="og:url" content="http://localhost:4000/2015/11/26/ajax.html" /><meta property="og:site_name" content="人間開花" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2015-11-26T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><script type="application/ld+json"> {"description":"Ajax（Asynchronous JavaScript + XML）技术能够向服务器请求额外数据并对页面进行一些填充处理但刷新页面，这会带来更好的用户体验。它依赖现有的CSS/HTML/JavaScript，其中技术核心是XMLHttpRequest对象（简称XHR），是这个对象使得浏览器可发出HTTP请求与接受HTTP请求。","@type":"BlogPosting","url":"http://localhost:4000/2015/11/26/ajax.html","headline":"XMLHttpRequest","dateModified":"2015-11-26T00:00:00+08:00","datePublished":"2015-11-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2015/11/26/ajax.html"},"@context":"http://schema.org"}</script><script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?f314392dea2501b163d8f0fd29b6864e"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })();</script><script async src="/js/theme.js"></script></head><body style="background-color: rgb(255, 255, 255)"><header><div class="links"> <a href="/" data-router="index">INDEX</a> <a href="/music/" data-router="music">MUSIC</a> <a href="/about/" data-router="about">ABOUT</a></div></header><main> <article class="blog-article"><h1 class="post-title">XMLHttpRequest</h1><p class="post-date"><small>November 26, 2015</small></p><div class="post-content"><p>Ajax（Asynchronous JavaScript + XML）技术能够向服务器请求额外数据并对页面进行一些填充处理但刷新页面，这会带来更好的用户体验。它依赖现有的CSS/HTML/JavaScript，其中技术核心是XMLHttpRequest对象（简称XHR），是这个对象使得浏览器可发出HTTP请求与接受HTTP请求。</p><h3 id="xmlhttprequest">XMLHttpRequest</h3><p>在使用XHR 对象时，要调用的第一个方法是open()，它接受 3 个参数</p><ul><li>要发送的请求的类型（”get”、”post”等）</li><li>请求的URL</li><li>表示是否异步发送请求的布尔值</li></ul><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">()</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.php"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</code></pre></div></div><p>URL相对于执行代码的当前页面（当然也可以使用绝对路径），二是调用open()方法并不会真正发送请求，而只是启动一个请求以备发送。只能向同一个域中使用相同端口和协议的URL发送请求。如果URL与启动请求的页面有任何差别，都会引发安全错误。要发送特定的请求，必须像下面这样调用send()方法</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">()</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.php"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div><p>这里的send()方法接收一个参数，即要作为请求主体发送的数据。如果不需要通过请求主体发送数据，则必须传入null，因为这个参数对有些浏览器来说是必需的。调用send()之后，请求就会被分派到服务器。</p><p>由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充XHR 对象的属性，相关的属性简介如下。</p><ul><li>responseText：作为响应主体被返回的文本。</li><li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM 文档。</li><li>status：响应的HTTP 状态。</li><li>statusText：HTTP 状态的说明。</li></ul><p>接收到响应后，第一步检查status属性，可以将HTTP状态代码为200 作为成功的标志。此时，responseText 属性的内容已经就绪，状态代码为304 表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.txt"</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span><span class="p">){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">responseText</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"Request was unsuccessful: "</span> <span class="o">+</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p>无论内容类型是什么，响应主体的内容都会保存到responseText 属性中；而 对于非XML 数据而言，responseXML 属性的值将为null。</p><h4 id="asynchronous-requests">Asynchronous Requests</h4><p>异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测XHR 对象的readyState 属性，该属性表示请求/响应过程的当前活动阶段。</p><ul><li>0 UNSENT（未初始化）。此时xhr对象被成功构造，open()方法还未被调用</li><li>1 OPENED (已打开，未发送)。open()方法已被成功调用，send()方法还未被调用</li><li>2 HEADERS_RECEIVED (已获取响应头)。send()方法已经被调用, 响应头和响应状态已经返回</li><li>3 LOADING (正在下载响应体)。响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据</li><li>4 DONE (整个数据传输过程结束)。整个数据传输过程结束，不管本次请求是成功还是失败</li></ul><p>只要readyState 属性的值由一个值变成另一个值，都会触发一次readystatechange 事件。可以利用这个事件来检测每次状态变化后readyState 的值。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span><span class="p">){</span>
            <span class="c1">//use responseText do something</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//request unsuccessful</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.txt"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div><p>这个例子在onreadystatechange 事件处理程序中使用了xhr 对象，没有使用this 对象，原因是onreadystatechange事件处理程序的作用域问题。如果使用this对象，在有的浏览器中会导致函数执行失败，或者导致错误发生。因此，使用实际的XHR 对象实例变量是较为可靠的一种方式。</p><p>在接收到响应之前还可以调用abort()方法来取消异步请求 <code class="highlighter-rouge">xhr.abort();</code></p><h4 id="http-header">HTTP Header</h4><p>每个HTTP 请求和响应都会带有相应的头部信息，默认情况下，在发送XHR 请求的同时，还会发送下列头部信息。</p><ul><li>Accept：浏览器能够处理的内容类型。</li><li>Accept-Charset：浏览器能够显示的字符集。</li><li>Accept-Encoding：浏览器能够处理的压缩编码。</li><li>Accept-Language：浏览器当前设置的语言。</li><li>Connection：浏览器与服务器之间连接的类型。</li><li>Cookie：当前页面设置的任何Cookie。</li><li>Host：发出请求的页面所在的域 。</li><li>Referer：发出请求的页面的URI。</li><li>User-Agent：浏览器的用户代理字符串。</li></ul><p>使用setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用open()方法之后且调用send()方法之前调用setRequestHeader()</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span><span class="p">){</span>
            <span class="c1">//use responseText do something</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//request unsuccessful</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.txt"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">'Content-Type'</span><span class="p">,</span><span class="s1">'application/x-www-form-urlencoded'</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div><p>建议使用自定义的头部字段名称，不要使用浏览器正常发送的字段名称，否则有可能会影响服务器的响应。</p><h4 id="get">GET</h4><p>GET 是最常见的请求类型，最常用于向服务器查询某些信息。使用GET请求经常会发生的一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，然后才能放到URL 的末尾；而且所有名-值对儿都必须由和号（&amp;）分隔</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">addURLParam</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="nx">name</span><span class="p">,</span><span class="nx">value</span><span class="p">){</span>  
    <span class="nx">url</span> <span class="o">+=</span> <span class="nx">url</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s1">'?'</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span> <span class="p">?</span> <span class="s1">'?'</span><span class="p">:</span><span class="s1">'&amp;'</span><span class="p">;</span>
    <span class="nx">url</span> <span class="o">+=</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">+</span> <span class="s1">'='</span> <span class="o">+</span> <span class="nb">encodeURIComponent</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">url</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>addURLParam三个参数：要添加参数的URL、参数的名称、参数的值。</p><h4 id="post">POST</h4><p>通常用于向服务器发送应该被保存的数据，相比GET，POST 请求的主体可以包含非常多的数据，而且格式不限。默认情况下，服务器对POST 请求和提交Web表单的请求并不会一视同仁。因此，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。不过可以使用XHR来模仿表单提交。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="nx">createXHR</span><span class="p">();</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">onreadystatechange</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">readyState</span> <span class="o">==</span> <span class="mi">4</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&gt;=</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">300</span><span class="p">)</span> <span class="o">||</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">status</span> <span class="o">==</span> <span class="mi">304</span><span class="p">){</span>
            <span class="c1">//use responseText do something</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//request unsuccessful</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"example.txt"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">setRequestHeader</span><span class="p">(</span><span class="s1">'Content-Type'</span><span class="p">,</span><span class="s1">'application/x-www-form-urlencoded'</span><span class="p">);</span> <span class="c1">//模拟头部表单提交</span>
<span class="kd">var</span> <span class="nx">form</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"user-info"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">serialize</span><span class="p">(</span><span class="nx">form</span><span class="p">));</span>  <span class="c1">//serialize 自定义表单序列化函数</span>
</code></pre></div></div><h4 id="formdata">FormData</h4><p>FormData 为序列化表单以及创建与表单格式相同的数据（用于通过XHR 传输）提供了便利</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">();</span>
<span class="nx">data</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s2">"name"</span><span class="p">,</span> <span class="s2">"Nicholas"</span><span class="p">);</span>  <span class="c1">//添加数据</span>

<span class="nx">or</span>

<span class="kd">var</span> <span class="nx">form</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"user-info"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="k">new</span> <span class="nx">FormData</span><span class="p">(</span><span class="nx">form</span><span class="p">));</span> <span class="c1">//实例化然后传给send()</span>
</code></pre></div></div><h3 id="xmlhttprequest-level2">XMLHttpRequest Level2</h3><p>XMLHttpRequest 2 级则进一步发展了XHR</p><h4 id="formdata-1">FormData</h4><p>XMLHttpRequest2提供了定义了FormData类型为表单数据的序列化提供便利。使用FormData 的方便之处体现在不必明确地在XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是FormData 的实例，并配置适当的头部信息。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"post"</span><span class="p">,</span><span class="s2">"postexample.php"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">form</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">"user-info"</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="k">new</span> <span class="nx">FormData</span><span class="p">(</span><span class="nx">form</span><span class="p">));</span>
</code></pre></div></div><h4 id="超时设定-ie8">超时设定 IE8+</h4><p>如果在规定的时间内浏览器还没有接收到响应，那么就会触发timeout事件，进而会调用ontimeout事件处理程序</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"get"</span><span class="p">,</span> <span class="s2">"timeout.php"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">timeout</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">//将超时设置为1秒钟</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">ontimeout</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"Request did not return in a second."</span><span class="p">);</span>
<span class="p">};</span>
<span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
</code></pre></div></div><h4 id="上传进度">上传进度</h4><p>Level2 中对xhr对象新增了一个upload属性，可以利用这个属性的onprogress方法进行文件图片资源上传进度监听。</p><div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;progress</span> <span class="na">id=</span><span class="s">"myProgress"</span> <span class="na">value=</span><span class="s">"0"</span> <span class="na">max=</span><span class="s">"100"</span><span class="nt">&gt;&lt;/progress&gt;</span>
</code></pre></div></div><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">xhr</span><span class="p">.</span><span class="nx">upload</span><span class="p">.</span><span class="nx">onprogress</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">lengthComputable</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 对进度进行处理</span>
        <span class="kd">var</span> <span class="nx">percentComplete</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">loaded</span> <span class="o">/</span> <span class="nx">event</span><span class="p">.</span><span class="nx">total</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">;</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">'myProgress'</span><span class="p">).</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">percentComplete</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><h3 id="jquery-ajax">jQuery ajax</h3><blockquote><p>jQuery 对 Ajax 做了大量的封装，我们使用起来也较为方便，不需要去考虑浏览器兼容性。对于封装的方式，jQuery采用了三层封装：最底层的封装方法为：$.ajax()，而通过这层封装了第二层有三种方法：.load()、$.get()和$.post()，最高层是$.getScript()和$.getJSON()方法。</p></blockquote><h4 id="低层封装">低层封装</h4><p><code class="highlighter-rouge">$.ajax([settings])</code> 执行一个异步的HTTP（Ajax）的请求</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">ajax</span><span class="p">({</span>
    <span class="na">url</span><span class="p">:</span><span class="s1">'url'</span>
    <span class="na">type</span><span class="p">:</span><span class="s1">'post'</span><span class="p">,</span>
    <span class="na">async</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:</span><span class="nx">data</span><span class="p">,</span>
    <span class="na">dataType</span><span class="p">:</span> <span class="s1">'json'</span><span class="p">,</span>
    <span class="na">success</span><span class="p">:</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){}</span>
<span class="p">});</span>
</code></pre></div></div><p>如果要处理$.ajax()得到的数据，则需要使用回调函数。</p><ul><li>beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。</li><li>error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）</li><li>dataFilter 在请求成功之后调用。传入返回的数据以及”dataType”参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。</li><li>success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。</li><li>complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。 <a href="http://jquery.cuishifeng.cn/jQuery.Ajax.html">jQuery $.ajax() API</a></li></ul><p><code class="highlighter-rouge">$.ajaxSetup[options]</code> 设置全局默认的Ajax默认选项</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">ajaxSetup</span><span class="p">({</span>
    <span class="na">type</span><span class="p">:</span><span class="s1">'post'</span><span class="p">,</span>
    <span class="na">async</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span>
    <span class="na">dataType</span><span class="p">:</span> <span class="s1">'json'</span><span class="p">,</span>
<span class="p">});</span>
</code></pre></div></div><p><code class="highlighter-rouge">ajaxStart()</code> 在Ajax请求发出前触发函数 <code class="highlighter-rouge">ajaxStop()</code> 在Ajax请求完成后触发函数 <code class="highlighter-rouge">$.ajaxError()</code> AJAX 请求发生错误时执行函数, Ajax Event。 <code class="highlighter-rouge">$.ajaxSuccess()</code> AJAX 请求成功时执行函数, Ajax Event。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ajaxStart</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span> <span class="s2">"#loading"</span> <span class="p">).</span><span class="nx">show</span><span class="p">();</span>
 <span class="p">});</span>
<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ajaxStop</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span> <span class="s2">"#loading"</span> <span class="p">).</span><span class="nx">hide</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div><h4 id="二层封装">二层封装</h4><p><code class="highlighter-rouge">$.get(url,[data],[callback])</code> 使用一个HTTP GET请求从服务器加载数据</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$.get('example.php', function(data){
    $('#test').html(data);
});
</code></pre></div></div><p><code class="highlighter-rouge">$.post(url,[callback])</code> 使用一个HTTP POST 请求从服务器加载数据</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$.post("example.php", $("#testform").serialize(), function(data){  //发送序列化表单数据
    console.log(data);
});
</code></pre></div></div><p><a href="http://jquery.cuishifeng.cn/jQuery.post.html">jQuery $.post API</a> <a href="http://jquery.cuishifeng.cn/jQuery.get.html">jQuery $.get API</a></p><h4 id="高层封装">高层封装</h4><p>getJSON()和getScript()是全局函数。</p><p><code class="highlighter-rouge">$.getJSON(url,[data],[callback])</code> 通过url获取JSON数据格式，然后使用回调函数将获取的数据进行后续操作。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="s1">'example.json'</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div><p><code class="highlighter-rouge">$.getScript(url,[callback])</code> 使用一个HTTP GET请求从服务器加载并执行一个JavaScript文件。 初次加载页面有些js文件不是必须的，可以通过getScript()灵活加载所需js文件。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">getScript</span><span class="p">(</span><span class="s1">'js/example.js'</span><span class="p">);</span>
</code></pre></div></div></div></article></main><footer><p class="copy"><small> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">CC BY-NC-ND 4.0</a> © SAKUYA 2015-2018 </small></p></footer><script async src="https://www.googletagmanager.com/gtag/js?id=UA-110493333-2"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-110493333-2');</script><script src="/js/zoom-image.js"></script><script src="/js/index.js"></script></body></html>
